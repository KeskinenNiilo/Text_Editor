import tkinter as tk
from tkinter import filedialog, PhotoImage
import tkinter.messagebox as msgbox
from tkinter.messagebox import askquestion
import ctypes
from google import genai
import dotenv
import os
import json
import sys

# Get settings.json, defaults last
try:
    with open('settings.json', 'r') as file:
        settings = json.load(file)
except:
    settings = {}

text_font = settings.get('text_settings', {}).get('text_font', 'Arial')
text_size = settings.get('text_settings', {}).get('text_size', '14')
file_save_on_exit = settings.get('file_settings', {}).get('file_save_on_exit', True)
ai_tools = settings.get('ai_settings', {}).get('ai_tools', True)

# AI tools, create an .env with API_KEY variable, or remove os.getenv and replace with yout api key 
if ai_tools:
    if os.path.exists('.env'):
        dotenv.load_dotenv() 
        api_key = os.getenv('API_KEY')
        if api_key:
            client = genai.Client(api_key=api_key)
            ai_model = 'gemini-2.0-flash'
        else: ai_tools = False
    else: ai_tools = False

# Less blurry on windows
if sys.platform == 'win32':
    ctypes.windll.shcore.SetProcessDpiAwareness(1)

# Root window
root = tk.Tk()
root.title('*')
root.geometry('1200x800')
file_name = ''

# Icon, delete if useless or replace icon.png with something else
photo = PhotoImage(file='icon.png')
root.iconphoto(False, photo)

# Text area
text_widget = tk.Text(root, font=(text_font, text_size))
text_widget.pack(fill='both', expand=True)

# Open file, if text in unsaved or already editing a file, asks to save
def open_file():
    global file_name
    text = text_widget.get('1.0', 'end')
    if text.strip() != '' or file_name != '*':
        if save_file_qstn(): save_file()
    file_path = filedialog.askopenfilename()
    if file_path:
        text_widget.delete('1.0', 'end')
        with open(file_path, 'r') as file:
            text_widget.insert('1.0', file.read())
            file_name = file_path
    root.title(file_name)

# Open file specified in call
if len(sys.argv) > 1:
    try:
        with open(sys.argv[1], 'r') as file:
            text_widget.insert('1.0', file.read())
            file_name = sys.argv[1]
            root.title(file_name)
    except FileNotFoundError:
        raise RuntimeError('No file found')

# Save with file dialog
def save_as_file():
    global file_name
    file_path = filedialog.asksaveasfilename()
    if file_path:
        with open(file_path, 'w') as file:
            file.write(text_widget.get('1.0', 'end'))
            file_name = file_path
    root.title(file_name)

# Save if file_name is not "*" or text is not null, if file_name is "*" -> save_as_file
def save_file():
    global file_name
    text = text_widget.get('1.0', 'end')
    if file_name == '' and text.strip() == '':
        return
    if file_name == '':
        save_as_file()
        return
    with open(file_name, 'w') as file:
        file.write(text)
    root.title(file_name)

# Bind CTRL + S to file save
root.bind('<Control-s>', save_file)

# File save question
def save_file_qstn():
    qstn = msgbox.askquestion('Save', 'Save changes?', icon='question')
    return qstn == 'yes'

# New file, almost same as open_file
def new_file():
    global file_name
    text = text_widget.get('1.0', 'end-1c').strip()
    if text != '' or file_name != '':
        if save_file_qstn(): save_file()
    file_name = ''
    text_widget.delete('1.0', 'end')
    root.title('*')

# Basic text editing util
def cut():
    text_widget.event_generate('<<Cut>>')
def copy():
    text_widget.event_generate('<<Copy>>')
def paste():
    text_widget.event_generate('<<Paste>>')
def select_all():
    text_widget.tag_add('sel', '1.0', 'end')

# AI spellcheck, replaces text with "correct" spelling, informs user that mistakes are likely
def googleAIspellcheck():
    global ai_model
    response = client.models.generate_content(
        model=ai_model,
        contents='Spellcheck this, return only the text in the same format: ' + text_widget.get(1.0, 'end'),
    )
    text_widget.delete('1.0', 'end')
    text_widget.insert('end', response.text)
    msgbox.showinfo('AI Info', f'Spelling checked by {ai_model}, check for errors.')

# Use text area as a prompt and replace, same infobox as spellcheck
def googleAIgenerate():
    global ai_model
    response = client.models.generate_content(
        model=ai_model,
        contents='Answer without adding any filler text' + text_widget.get(1.0, 'end'),
    )
    text_widget.delete('1.0', 'end')
    text_widget.insert('end', response.text)
    msgbox.showinfo('AI Info', f'Generated by {ai_model}, check for errors.')

# Ask to save file if user has file_save_on_exit as true, 
def quit_app():
    text = text_widget.get('1.0', 'end').strip()
    if file_save_on_exit and (text != '' or file_name != '*'):
        if save_file_qstn(): save_file()
    root.quit()
    root.destroy()

# Override X button to quit_app
root.protocol('WM_DELETE_WINDOW', quit_app);

# Menu bar
menu_bar = tk.Menu(root)

file_menu = tk.Menu(menu_bar, tearoff=0)
file_menu.add_command(label='Open', command=open_file)
file_menu.add_command(label='Save as', command=save_as_file)
file_menu.add_command(label='Save', command=save_file)
file_menu.add_separator()
file_menu.add_command(label='New', command=new_file)
file_menu.add_separator()
file_menu.add_command(label='Exit', command=quit_app)
menu_bar.add_cascade(label='File', menu=file_menu)


edit_menu = tk.Menu(menu_bar, tearoff=0)
edit_menu.add_command(label='Cut', command=cut)
edit_menu.add_command(label='Copy', command=copy)
edit_menu.add_command(label='Paste', command=paste)
edit_menu.add_separator()
edit_menu.add_command(label='Select All', command=select_all)
menu_bar.add_cascade(label='Edit', menu=edit_menu)
if ai_tools:
    ai_menu = tk.Menu(menu_bar, tearoff=0)
    ai_menu.add_command(label='Spellcheck', command=googleAIspellcheck)
    ai_menu.add_command(label='Generate', command=googleAIgenerate)
    menu_bar.add_cascade(label='AI', menu=ai_menu)

root.config(menu=menu_bar)

# Main window loop
root.mainloop()
